#include "absenc.h"
#include "math.h"
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"
#include <cmath>
#include <memory>
#include <chrono>
#include <array>
#include <cmath>
#include <string>
#include <limits>
/*Include autogenerated message header*/
#include "absenc_interface/msg/encoder_values.hpp"
// #include "arm_controller/msg/arm_motor_values.hpp"
#include <std_msgs/msg/float32_multi_array.hpp>
#include <sensor_msgs/msg/joint_state.hpp>
#include <sensor_msgs/msg/joy.hpp>

#define GAIN 25.0

  using namespace std::chrono_literals;
  #define GAIN 20.0

  float scaleClamp(float val, float scale, float min, float max) {
    val *= scale;
    val = val < min ? min : val;
    val = val > max ? max : val;
    return val;
  }

  Absenc::Absenc() : LifecycleNode("absenc_node"){
    this->declare_parameter("absenc_path", "/dev/ttyUSB0");
    this->declare_parameter("local_mode", false);
    this->declare_parameter("absenc_polling_rate", 100);
  }

  callbackReturn Absenc::on_configure(const rclcpp_lifecycle::State &){
    RCLCPP_DEBUG_STREAM(get_logger(), "Starting absenc node\n");
        /*
      Set default parameter for the filepath of the absenc. To set, use 
      ros2 run absenc_interface absenc_node --ros-args -p absenc_polling_rate:=1000
      or during runtime (when the node is already running) as 
      ros2 param set /absenc_node absenc_polling_rate 1000 
    */
    // RCLCPP_DEBUG_STREAM(get_logger(), state.label());

    bool local_mode = this->get_parameter("local_mode").as_bool();

    angles_publisher = this->create_publisher<absenc_interface::msg::EncoderValues>("absenc_values", 10);

    arm_publisher = this->create_publisher<std_msgs::msg::String>("arm_command", 10);
    
    timer = this->create_wall_timer(
    std::chrono::milliseconds(this->get_parameter("absenc_polling_rate").as_int()), 
    std::bind(&Absenc::absEncPollingCallback, this));
    
    /*
      Open serial to RS485 device
    */
    RCLCPP_DEBUG_STREAM(get_logger(), "About to open serial connection\n");

    while (!local_mode) {
      ABSENC_Error_t err = AbsencDriver::OpenPort(this->get_parameter("absenc_path").as_string().c_str(),B57600, s_fd);
      if(err.error != 0){
        RCLCPP_ERROR(this->get_logger(),"Error opening file : %i. Message: %s\n", err.error, strerror(err.error));
        // Wait 5 seconds before attempting reconnection
        rclcpp::sleep_for(std::chrono::seconds(5));
      } else {
        break;
      }

      if (!rclcpp::ok()) {
        return callbackReturn::FAILURE;
      }
    }

    subscription = this->create_subscription<sensor_msgs::msg::JointState>(
      "joint_states", 10, std::bind(&Absenc::ikValuesCallback, this, std::placeholders::_1));

    subscription_cad_mouse = this->create_subscription<sensor_msgs::msg::Joy>(
      "cad_mouse_joy", 10, std::bind(&Absenc::cadValuesCallback, this, std::placeholders::_1));

    subscription_joy = this->create_subscription<sensor_msgs::msg::Joy>(
      "joy", 10, std::bind(&Absenc::joyValuesCallback, this, std::placeholders::_1));
    RCLCPP_ERROR(this->get_logger(), "Done, got joint_states");
    

    arm_controller_publisher = this->create_publisher<std_msgs::msg::Float32MultiArray>("arm_values",10);
    
    RCUTILS_LOG_INFO_NAMED(get_name(), "on_configure() is called.");
    return callbackReturn::SUCCESS;
  }

  callbackReturn Absenc::on_activate(const rclcpp_lifecycle::State & state){
    LifecycleNode::on_activate(state);

    RCUTILS_LOG_INFO_NAMED(get_name(), "on_activate() is called.");

    return callbackReturn::SUCCESS;
  }

  callbackReturn Absenc::on_deactivate(const rclcpp_lifecycle::State & state){
    LifecycleNode::on_deactivate(state);

    RCUTILS_LOG_INFO_NAMED(get_name(), "on_deactivate() is called.");
    return callbackReturn::SUCCESS;
  }

  callbackReturn Absenc::on_cleanup(const rclcpp_lifecycle::State &){
    timer.reset();
    angles_publisher.reset();
    arm_publisher.reset();

    RCUTILS_LOG_INFO_NAMED(get_name(), "on cleanup is called.");
    return callbackReturn::SUCCESS;
  }

  callbackReturn Absenc::on_shutdown(const rclcpp_lifecycle::State & state){
    timer.reset();
    angles_publisher.reset();
    arm_publisher.reset();

    RCUTILS_LOG_INFO_NAMED(
        get_name(),
        "on shutdown is called from state %s.",
        state.label().c_str()
    );

    rclcpp::shutdown();
    return callbackReturn::SUCCESS;
  }

  Absenc::~Absenc() {
    if (s_fd >= 0) {
      AbsencDriver::ClosePort(s_fd);
    }
  }

void Absenc::absEncPollingCallback(){
  if (this->get_parameter("local_mode").as_bool()){
    return;
  }

  auto message = absenc_interface::msg::EncoderValues();     

  ABSENC_Meas_t absenc_meas_1,absenc_meas_2,absenc_meas_3;

  ABSENC_Error_t err1 = AbsencDriver::PollSlave(1,&absenc_meas_1, s_fd);
  ABSENC_Error_t err2 = AbsencDriver::PollSlave(2,&absenc_meas_2, s_fd);
  ABSENC_Error_t err3 = AbsencDriver::PollSlave(3,&absenc_meas_3, s_fd);
  
  /*
  Check to see if there were any fails at the serial level
  */
  if (err1.error != NO_ERROR) {
    RCLCPP_ERROR(this->get_logger(), "Error on 1: %s cause %d line %d\n", strAbsencErr(err1.error), err1.cause, err1.line);
  }
  if (err2.error != NO_ERROR) {
    RCLCPP_ERROR(this->get_logger(), "Error on 2: %s cause %d line %d\n", strAbsencErr(err2.error), err2.cause, err2.line);
  }
  if (err3.error != NO_ERROR) {
    RCLCPP_ERROR(this->get_logger(), "Error on 3: %s cause %d line %d\n", strAbsencErr(err3.error), err3.cause, err3.line);
  }

  /*
    Absencs will report a non-zero status if there is a hardware/communications issue
  */
  if(absenc_meas_1.status != 0 || absenc_meas_2.status != 0 || absenc_meas_3.status != 0){
      RCLCPP_ERROR(this->get_logger(),
          "One of the absenc status returned an error. Here are the error codes: %d %d %d \n", absenc_meas_1.status, absenc_meas_2.status, absenc_meas_3.status);
      // Sets the values to NaN as an indicator the latest values are unknown
      for (int i = 0; i < std::size(abs_angles); i++) {
          abs_angles[i] = std::numeric_limits<double>::quiet_NaN();
      }
      return;
  }
  message.angle_1 = (absenc_meas_1.angval < 0 ? absenc_meas_1.angval + 180.f : absenc_meas_1.angval - 180);
  message.angle_2 = absenc_meas_2.angval;
  message.angle_3 = absenc_meas_3.angval < 0 ? 180 + absenc_meas_3.angval : absenc_meas_3.angval - 180.f;

  // std::cout << message.angle_1 << std::endl;
  // std::cout << message.angle_2 << std::endl;
  // std::cout << message.angle_3 << std::endl;
  
  // hold onto value for control system
  abs_angles[0] = 0.0; // placeholder for if fourth encoder
  abs_angles[1] = message.angle_1;
  abs_angles[2] = message.angle_2;
  abs_angles[3] = message.angle_3;

  //TODO : Can simplify this a bit. 
  angles_publisher->publish(message);
}

void Absenc::cadValuesCallback(const sensor_msgs::msg::Joy::SharedPtr msg) {
  if (msg->axes.size() < 6) {
    RCLCPP_ERROR(this->get_logger(),"Axes of cad mouse wrong dimension");
  }
  if (msg->buttons.size() < 2) {
    RCLCPP_ERROR(this->get_logger(),"Axes of cad mouse wrong dimension");
  }

  float x = msg->axes[0];
  float y = msg->axes[1];
  float z = msg->axes[2];
  float pitch = msg->axes[3];
  float roll = msg->axes[4];
  float yaw = msg->axes[5];

  base_motor_input = yaw;
  int leftButton = msg->buttons[0];
  int rightButton = msg->buttons[1];
  inhibitArmMovement = rightButton == 0;

  if (!inhibitArmMovement) {
    controlEndEffector(yaw, x);
  }
}

void Absenc::joyValuesCallback(const sensor_msgs::msg::Joy::SharedPtr msg) {
  if (msg->axes.size() < 6) {
    RCLCPP_ERROR(this->get_logger(),"Axes of joy wrong dimension");
  }
  if (msg->buttons.size() < 11) {
    RCLCPP_ERROR(this->get_logger(),"Axes of joy wrong dimension");
  }
  // Ensure not pressing button 3 (when pressing button 3, moving wheels)
  if (msg->buttons[2] == 0) {
    base_motor_input = msg->axes[2];
  }
  inhibitArmMovement = false;
  claw_spin = msg->axes[5];
  claw_close = msg->buttons[4] - msg->buttons[5];
  // controlEndEffector(spin, openClose);
}

void Absenc::ikValuesCallback(const sensor_msgs::msg::JointState::SharedPtr msg) {
  // Convert ik angles to degrees
  for (int i = 0; i < 4; i++) {
    ik_angles[i] = msg->position[i] * 180.0 / M_PI;
  }
  if (inhibitArmMovement) {
        // RCLCPP_ERROR(this->get_logger(), "arm movement inhibited");
    // Then should be controlling the end effector directly; abort here
    return;
  }
  if (std::isnan(abs_angles[0])) {
        RCLCPP_ERROR(this->get_logger(), "abs angle are nan");
    // Don't have latest values, return
    return;
  }

  std::string arm_command = "set_motor_speeds ";

  auto arm_msg = std_msgs::msg::Float32MultiArray();


  // auto layout = std_msgs::msg::MultiArrayLayout();
  // auto dim = std::msgs::msg::MultiArrayDimension();

  std::vector<float> angles(6);


  // std::cout << "Angles: ";
  // for (int i = 0; i < std::size(ik_angles); i++) {
  //   std::cout << "ik " << ik_angles[i] << " abs " << abs_angles[i] << " ";
  // }
  // std::cout << "\n";


  // Set the base motor speed from the cad mouse directly
  angles[0] = scaleClamp(base_motor_input, -1.00, -1.0, 1.0);
  arm_command += std::to_string(angles[0]);
  arm_command += " ";

  // Only the three middle motors have values provided by IK
  for (int i = 1; i < std::size(ik_angles); i++) {
    float absenc_angle = abs_angles[i];
    float ik_angle = ik_angles[i];
    float motor_sign = motor_signs[i];

    float absolute_difference = std::abs(absenc_angle - ik_angle);
    int difference_sign = absenc_angle - ik_angle >= 0 ? 1 : -1;

    if (absolute_difference == 0) {
      // NICK SHIT
      angles[i] = 0;
      arm_command += "0 ";
    } else {
      // Get motor value from difference from desired position, with gain 200
      float value = ((absolute_difference) / 180.0) * GAIN;
      // Clamp
      value = value > 1.0 ? 1.0 : value;
      // Account for sign differences
      value *= difference_sign;
      value *= motor_sign;
      // Add to msg
      int intVal = (int)value;
      
      // NICK SHIT
      angles[i] = value;

      arm_command += std::to_string(intVal);
      arm_command += " ";
    }
  }
    
  // Add 0 values for two last values
  arm_command += "0 0";
    // NICK SHIT
  angles[4] = claw_spin;
  angles[5] = claw_close;
  
  auto arm_msg_s = std_msgs::msg::String();
  arm_msg_s.data = arm_command;
  arm_publisher->publish(arm_msg_s);
  
  arm_msg.data = angles;
  arm_controller_publisher->publish(arm_msg);
}


void Absenc::controlEndEffector(float spin, float close) {
  auto arm_msg_2 = std_msgs::msg::Float32MultiArray();
  std::vector<float> angles(6);

  // Zero out values
  for (int i = 0; i < 4; i++) {
    angles[i] = 0;
  }

  // Control the end effector motors with 3d mouse
  angles[4] = scaleClamp(spin, 1.00, -1.0, 1.0);
  angles[5] = scaleClamp(close, 1.00, -1.0, 1.0);

  arm_msg_2.data = angles;
  arm_controller_publisher->publish(arm_msg_2);
}



int main(int argc, char * argv[])
{
  std::cout << "Starting absenc node\n";
  rclcpp::init(argc, argv);
  rclcpp::executors::SingleThreadedExecutor exe;

  std::shared_ptr<Absenc> abs_node = std::make_shared<Absenc>();

  exe.add_node(abs_node->get_node_base_interface());
  exe.spin();

  rclcpp::shutdown();
  return 0;
}
