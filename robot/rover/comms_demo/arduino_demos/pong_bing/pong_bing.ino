#include <Arduino.h>
#include "SPI.h"

/*
 * TLE5012 magnetic encoder. Implemented with SSC ( 3 wire SPI )
 */
#define CS_PIN 10
#define CLOCK_RATE 100'000
#define CRC_DEFAULT_VALUE 0xFF
#define REG_STATUS    (0x00)
#define REG_ANGLE_VAL (0x02)
#define REG_ADC_X     (0x10)
#define REG_ADC_Y     (0x11)
#define REG_T_RAW     (0x15)
#define REG_T25O      (0x30)
#define REG_TCO_X     (0x0E)
#define REG_TCO_Y     (0x0F)

uint16_t data;
uint16_t safety;
uint8_t  crc;


volatile int crc_fail_cnt=0;
volatile int device_lost_cnt=0;
volatile  int total_requests_ctn = 0;
const uint8_t CRC_Table[256]
        {
//The “crc” of the position [1] (result from operation [crc ^*(message+Byteidx)])
//is 0x00 -> 0x00 XOR 0x11D = 0x00 (1 byte).
                0x00,
//The “crc” of the position [2] is 0x1D -> 0x01 XOR 0x11D = 0x1D (1 byte).
                0x1D,
//The “crc” of the position [3] is 0x3A -> 0x02 XOR 0x11D = 0x3A (1 byte).
                0x3A,
//For all the rest of the cases.
                0x27, 0x74, 0x69, 0x4E, 0x53, 0xE8, 0xF5, 0xD2, 0xCF, 0x9C, 0x81, 0xA6, 0xBB, 0xCD,
                0xD0, 0xF7, 0xEA, 0xB9, 0xA4, 0x83, 0x9E, 0x25, 0x38, 0x1F, 0x02, 0x51, 0x4C, 0x6B,
                0x76, 0x87, 0x9A, 0xBD, 0xA0, 0xF3, 0xEE, 0xC9, 0xD4, 0x6F, 0x72, 0x55, 0x48, 0x1B,
                0x06, 0x21, 0x3C, 0x4A, 0x57, 0x70, 0x6D, 0x3E, 0x23, 0x04, 0x19, 0xA2, 0xBF, 0x98,
                0x85, 0xD6, 0xCB, 0xEC, 0xF1, 0x13, 0x0E, 0x29, 0x34, 0x67, 0x7A, 0x5D, 0x40, 0xFB,
                0xE6, 0xC1, 0xDC, 0x8F, 0x92, 0xB5, 0xA8, 0xDE, 0xC3, 0xE4, 0xF9, 0xAA, 0xB7, 0x90,
                0x8D, 0x36, 0x2B, 0x0C, 0x11, 0x42, 0x5F, 0x78, 0x65, 0x94, 0x89, 0xAE, 0xB3, 0xE0,
                0xFD, 0xDA, 0xC7, 0x7C, 0x61, 0x46, 0x5B, 0x08, 0x15, 0x32, 0x2F, 0x59, 0x44, 0x63,
                0x7E, 0x2D, 0x30, 0x17, 0x0A, 0xB1, 0xAC, 0x8B, 0x96, 0xC5, 0xD8, 0xFF, 0xE2, 0x26,
                0x3B, 0x1C, 0x01, 0x52, 0x4F, 0x68, 0x75, 0xCE, 0xD3, 0xF4, 0xE9, 0xBA, 0xA7, 0x80,
                0x9D, 0xEB, 0xF6, 0xD1, 0xCC, 0x9F, 0x82, 0xA5, 0xB8, 0x03, 0x1E, 0x39, 0x24, 0x77,
                0x6A, 0x4D, 0x50, 0xA1, 0xBC, 0x9B, 0x86, 0xD5, 0xC8, 0xEF, 0xF2, 0x49, 0x54, 0x73,
                0x6E, 0x3D, 0x20, 0x07, 0x1A, 0x6C, 0x71, 0x56, 0x4B, 0x18, 0x05, 0x22, 0x3F, 0x84,
                0x99, 0xBE, 0xA3, 0xF0, 0xED, 0xCA, 0xD7, 0x35, 0x28, 0x0F, 0x12, 0x41, 0x5C, 0x7B,
                0x66, 0xDD, 0xC0, 0xE7, 0xFA, 0xA9, 0xB4, 0x93, 0x8E, 0xF8, 0xE5, 0xC2, 0xDF, 0x8C,
                0x91, 0xB6, 0xAB, 0x10, 0x0D, 0x2A, 0x37, 0x64, 0x79, 0x5E, 0x43, 0xB2, 0xAF, 0x88,
                0x95, 0xC6, 0xDB, 0xFC, 0xE1, 0x5A, 0x47, 0x60, 0x7D, 0x2E, 0x33, 0x14, 0x09, 0x7F,
                0x62, 0x45, 0x58, 0x0B, 0x16, 0x31, 0x2C, 0x97, 0x8A, 0xAD, 0xB0, 0xE3, 0xFe,
//The “crc” of the position [255] is 0xD9 -> 0xFE XOR 0x11D = 0xD9 (1 byte).
                0xD9,
//The “crc” of the position [256] is 0xC4 -> 0xFF XOR 0x11D = 0xC4 (1 byte).
                0xC4};

uint8_t CRC8(const uint8_t* message,uint8_t length){
    uint8_t crc = CRC_DEFAULT_VALUE;

    for(int i = 0 ; i < length ; i++){
        //Serial.write(*(message+1));
        crc = CRC_Table[crc ^ *(message + i)];
    }
    return (~crc);
}

SPISettings TLE5012B_SPI_SETTINGS(CLOCK_RATE, MSBFIRST, SPI_MODE1);

int checkAddress(uint8_t txAddress, uint8_t rxAddress){

    uint8_t lower = txAddress & 0xF0;

    if(rxAddress == (lower | (lower >>4))){
        return 1;
    }
    return -1;
}

void registerRead16(int address,uint8_t reg, uint8_t size) {

    SPI.beginTransaction(TLE5012B_SPI_SETTINGS);

    uint16_t command = (1 << 15) | (reg << 4) | (size & 0x0F);


    digitalWrite(CS_PIN, LOW);

    uint8_t rx_byte = SPI.transfer(address);

    if(checkAddress(address,rx_byte) == -1){
//        Serial.print("Address fail , encoder : ");
//        Serial.println(address,HEX);
        device_lost_cnt++;
    }
    SPI.transfer16(command);

    data = SPI.transfer16(0x00);

    uint16_t message[2] = {
            static_cast<uint16_t>((command >> 8) | (command << 8)),
            static_cast<uint16_t>((data >> 8) | (data << 8))
    };

    safety = SPI.transfer16(0x00);

    crc = CRC8((uint8_t*)message,sizeof(message));


    // Compare the CRC byte from the safety word and the computed byte
    if(crc != (safety&0xFF)){
      //  Serial.println("CRC FAIL");
        crc_fail_cnt++;

    }
    else {
        float angle_deg = (float) (data & 0x7FFF) / (powf(2, 15)) * 360.f;

        Serial.print(address,HEX);
        Serial.print(",");
        Serial.println(angle_deg);

    }
    total_requests_ctn++;
    digitalWrite(CS_PIN,HIGH);

    SPI.endTransaction();
}
void setup() {
    Serial.begin(9600);
    pinMode(CS_PIN, OUTPUT);
    SPI.begin();
}

void loop() {;
//    registerRead16(0x90,REG_ANGLE_VAL,1);
//    delay(2);
//    registerRead16(0xA0,REG_ANGLE_VAL,1);
//    delay(2);
    registerRead16(0x90,REG_ANGLE_VAL,1);
    delay(500);

//    if( (total_requests_ctn % 300) == 0){
//        Serial.print("total requests : ");
//        Serial.println(total_requests_ctn);
//        Serial.print("CRC fails : ");
//        Serial.println(crc_fail_cnt);
//        Serial.print("Address fails : ");
//        Serial.println(device_lost_cnt);
//
//        delay(500);
//    }

}
